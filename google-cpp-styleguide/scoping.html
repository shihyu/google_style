

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. 作用域 &mdash; Google 開源項目風格指南</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Google 開源項目風格指南" href="../index.html" />
    <link rel="up" title="C++ 風格指南 - 內容目錄" href="contents.html" />
    <link rel="next" title="3. 類" href="classes.html" />
    <link rel="prev" title="1. 標頭檔" href="headers.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Google 開源項目風格指南</span></a></h1>
        <h2 class="heading"><span>2. 作用域</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="headers.html">1. 標頭檔</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../contents.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="classes.html">3. 類</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>2. 作用域</h1>
<div class="section" id="namespaces">
<span id="id2"></span><h2>2.1. 名字空間</h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">鼓勵在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案內使用匿名名字空間. 使用具名的名字空間時, 其名稱可基于項目名或相對路徑. 不要使用 <em>using 關鍵字</em>.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>名字空間將全局作用域細分為獨立的, 具名的作用域, 可有效防止全局作用域的命名衝突.</dd>
<dt>優點:</dt>
<dd><p class="first">雖然類已經提供了（可嵌套的）命名軸線 (YuleFox 註: 將命名分割在不同類的作用域內), 名字空間在這基礎上又封裝了一層.</p>
<p class="last">舉例來說, 兩個不同項目的全局作用域都有一個類 <tt class="docutils literal"><span class="pre">Foo</span></tt>, 這樣在編譯或運行時造成衝突. 如果每個項目將代碼置於不同名字空間中, <tt class="docutils literal"><span class="pre">project1::Foo</span></tt> 和 <tt class="docutils literal"><span class="pre">project2::Foo</span></tt> 作為不同符號自然不會衝突.</p>
</dd>
<dt>缺點:</dt>
<dd><p class="first">名字空間具有迷惑性, 因為它們和類一樣提供了額外的 (可嵌套的) 命名軸線.</p>
<p class="last">在標頭檔中使用匿名空間導致違背 C++ 的唯一定義原則 (One Definition Rule (ODR)).</p>
</dd>
<dt>結論:</dt>
<dd>根據下文將要提到的策略合理使用命名空間.</dd>
</dl>
<div class="section" id="id3">
<h3>2.1.1. 匿名名字空間</h3>
<ul>
<li><dl class="first docutils">
<dt>在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案中, 允許甚至鼓勵使用匿名名字空間, 以避免運行時的命名衝突:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="p">{</span>                             <span class="c1">// .cc 檔案中</span>

<span class="c1">// 名字空間的內容無需縮進</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">kUNUSED</span><span class="p">,</span> <span class="n">kEOF</span><span class="p">,</span> <span class="n">kERROR</span> <span class="p">};</span>         <span class="c1">// 經常使用的符號</span>
<span class="kt">bool</span> <span class="n">AtEof</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pos_</span> <span class="o">==</span> <span class="n">kEOF</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// 使用本名字空間內的符號 EOF</span>

<span class="p">}</span> <span class="c1">// namespace</span>
</pre></div>
</div>
</dd>
</dl>
<p>然而, 與特定類關聯的檔案作用域聲明在該類中被聲明為類型, 靜態數據成員或靜態成員函數, 而不是匿名名字空間的成員. 如上例所示, 匿名空間結束時用註釋 <tt class="docutils literal"><span class="pre">//</span> <span class="pre">namespace</span></tt> 標識.</p>
</li>
<li><p class="first">不要在 <tt class="docutils literal"><span class="pre">.h</span></tt> 檔案中使用匿名名字空間.</p>
</li>
</ul>
</div>
<div class="section" id="id4">
<h3>2.1.2. 具名的名字空間</h3>
<p>具名的名字空間使用方式如下:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>用名字空間把檔案包含, <a class="reference external" href="http://code.google.com/p/google-gflags/">gflags</a> 的聲明/定義, 以及類的前置聲明以外的整個源檔案封裝起來, 以區別于其它名字空間:</dt>
<dd><div class="first highlight-c++"><pre>// .h 檔案
namespace mynamespace {

// 所有聲明都置於命名空間中
// 注意不要使用縮進
class MyClass {
    public:
    …
    void Foo();
};

} // namespace mynamespace</pre>
</div>
<div class="highlight-c++"><pre>// .cc 檔案
namespace mynamespace {

// 函數定義都置於命名空間中
void MyClass::Foo() {
    …
}

} // namespace mynamespace</pre>
</div>
<p>通常的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案包含更多, 更複雜的細節, 比如引用其他名字空間的類等.</p>
<div class="last highlight-c++"><pre>#include “a.h”

DEFINE_bool(someflag, false, “dummy flag”);

class C;                    // 全局名字空間中類 C 的前置聲明
namespace a { class A; }    // a::A 的前置聲明

namespace b {

…code for b…                // b 中的代碼

} // namespace b</pre>
</div>
</dd>
</dl>
</li>
<li><p class="first">不要在名字空間 <tt class="docutils literal"><span class="pre">std</span></tt> 內聲明任何東西, 包括標準庫的類前置聲明. 在 <tt class="docutils literal"><span class="pre">std</span></tt> 名字空間聲明實體會導致不確定的問題, 比如不可移植. 聲明標準庫下的實體, 需要包含對應的標頭檔.</p>
</li>
<li><p class="first">最好不要使用 <em>``using`` 關鍵字</em>, 以保證名字空間下的所有名稱都可以正常使用.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 禁止 —— 污染名字空間</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案, <tt class="docutils literal"><span class="pre">.h</span></tt> 檔案的函數, 方法或類中, 可以使用 <em>``using`` 關鍵字</em>.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 允許: .cc 檔案中</span>
<span class="c1">// .h 檔案的話, 必須在函數, 方法或類的內部使用</span>
<span class="k">using</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案, <tt class="docutils literal"><span class="pre">.h</span></tt> 檔案的函數, 方法或類中, 允許使用名字空間別名.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 允許: .cc 檔案中</span>
<span class="c1">// .h 檔案的話, 必須在函數, 方法或類的內部使用</span>

<span class="k">namespace</span> <span class="n">fbz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="id5">
<h2>2.2. 嵌套類</h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">當公有嵌套類作為介面的一部分時, 雖然可以直接將他們保持在全局作用域中, 但將嵌套類的聲明置於名字空間內是更好的選擇.</p>
</div>
<dl class="docutils">
<dt>定義: 在一個類內部定義另一個類; 嵌套類也被稱為 <em>成員類 (member class)</em>.</dt>
<dd><div class="first last highlight-c++"><pre>class Foo {

private:
    // Bar是嵌套在Foo中的成員類
    class Bar {
        …
    };

};</pre>
</div>
</dd>
<dt>優點:</dt>
<dd>當嵌套 (或成員) 類只被外圍類使用時非常有用; 把它作為外圍類作用域內的成員, 而不是去污染外部作用域的同名類. 嵌套類可以在外圍類中做前置聲明, 然後在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案中定義, 這樣避免在外圍類的聲明中定義嵌套類, 因為嵌套類的定義通常只與實現相關.</dd>
<dt>缺點:</dt>
<dd>嵌套類只能在外圍類的內部做前置聲明. 因此, 任何使用了 <tt class="docutils literal"><span class="pre">Foo::Bar*</span></tt> 指針的標頭檔不得不包含類 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的整個聲明.</dd>
<dt>結論:</dt>
<dd>不要將嵌套類定義成公有, 除非它們是介面的一部分, 比如, 嵌套類含有某些方法的一組選項.</dd>
</dl>
</div>
<div class="section" id="id6">
<h2>2.3. 非成員函數, 靜態成員函數, 和全局函數</h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用靜態成員函數或名字空間內的非成員函數, 儘量不要用裸的全局函數.</p>
</div>
<dl class="docutils">
<dt>優點:</dt>
<dd>某些情況下, 非成員函數和靜態成員函數是非常有用的, 將非成員函數放在名字空間內可避免污染全局作用域.</dd>
<dt>缺點:</dt>
<dd>將非成員函數和靜態成員函數作為新類的成員或許更有意義, 當它們需要訪問外部資源或具有重要的依賴關係時更是如此.</dd>
<dt>結論:</dt>
<dd><p class="first">有時, 把函數的定義同類的實例脫鈎是有益的, 甚至是必要的. 這樣的函數可以被定義成靜態成員, 或是非成員函數. 非成員函數不應依賴于外部變數, 應儘量置於某個名字空間內. 相比單純為了封裝若干不共享任何靜態數據的靜態成員函數而創建類, 不如使用命名空間.</p>
<p>定義在同一編譯單元的函數, 被其他編譯單元直接調用可能會引入不必要的耦合和連結時依賴; 靜態成員函數對此尤其敏感. 可以考慮提取到新類中, 或者將函數置於獨立庫的名字空間內.</p>
<p class="last">如果你必須定義非成員函數, 又只是在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 檔案中使用它, 可使用匿名名字空間或 <tt class="docutils literal"><span class="pre">static</span></tt> 連結關鍵字 (如 <tt class="docutils literal"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">Foo()</span> <span class="pre">{...}</span></tt>) 限定其作用域.</p>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h2>2.4. 局部變數</h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">將函數變數儘可能置於最小作用域內, 並在變數聲明時進行初始化.</p>
</div>
<dl class="docutils">
<dt>C++ 允許在函數的任何位置聲明變數. 我們提倡在儘可能小的作用域中聲明變數, 離第一次使用越近越好. 這使得代碼瀏覽者更容易定位變數聲明的位置, 瞭解變數的類型和初始值. 特別是，應使用初始化的方式替代聲明再賦值, 比如:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// 壞——初始化和聲明分離</span>
<span class="n">nt</span> <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span> <span class="c1">// 好——初始化時聲明</span>
</pre></div>
</div>
</dd>
<dt>注意, GCC 可正確實現了 <tt class="docutils literal"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10;</span> <span class="pre">++i)</span></tt> (<tt class="docutils literal"><span class="pre">i</span></tt> 的作用域僅限 <tt class="docutils literal"><span class="pre">for</span></tt> 循環內), 所以其他 <tt class="docutils literal"><span class="pre">for</span></tt> 循環中可以重新使用 <tt class="docutils literal"><span class="pre">i</span></tt>. 在 <tt class="docutils literal"><span class="pre">if</span></tt> 和 <tt class="docutils literal"><span class="pre">while</span></tt> 等語句中的作用域聲明也是正確的, 如:</dt>
<dd><div class="first highlight-c++"><pre>while (const char* p = strchr(str, ‘/’)) str = p + 1;</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">如果變數是一個對象, 每次進入作用域都要調用其建構子, 每次退出作用域都要調用其解構子.</p>
</div>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// 低效的實現</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                  <span class="c1">// 建構子和解構子分別調用 1000000 次!</span>
<span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>在循環作用域外面聲明這類變數要高效的多:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                      <span class="c1">// 建構子和解構子隻調用 1 次</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h2>2.5. 靜態和全局變數</h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">禁止使用 <tt class="docutils literal"><span class="pre">class</span></tt> 類型的靜態或全局變數: 它們會導致很難發現的 bug 和不確定的構造和解構子調用順序.</p>
</div>
<p>靜態生存周期的對象, 包括全局變數, 靜態變數, 靜態類成員變數, 以及函數靜態變數, 都必須是原生數據類型 (POD : Plain Old Data): 只能是 <cite>int</cite>, <cite>char</cite>, <cite>float</cite>, 和 <cite>void</cite>, 以及 POD 類型的數組/結構體/指針. 永遠不要使用函數返回值初始化靜態變數; 不要在多綫程代碼中使用非 <tt class="docutils literal"><span class="pre">const</span></tt> 的靜態變數.</p>
<p>不幸的是, 靜態變數的建構子, 解構子以及初始化操作的調用順序在 C++ 標準中未明確定義, 甚至每次編譯構建都有可能會發生變化, 從而導致難以發現的 bug. 比如, 結束程序時, 某個靜態變數已經被析構了, 但代碼還在跑 &#8211; 其它綫程很可能 &#8211; 試圖訪問該變數, 直接導致崩潰.</p>
<p>所以, 我們只允許 POD 類型的靜態變數. 本條規則完全禁止 <tt class="docutils literal"><span class="pre">vector</span></tt> (使用 C 數組替代), <tt class="docutils literal"><span class="pre">string</span></tt> (使用 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt>), 及其它以任意方式包含或指向類實例的東東, 成為靜態變數. 出於同樣的理由, 我們不允許用函數返回值來初始化靜態變數.</p>
<p>如果你確實需要一個 <tt class="docutils literal"><span class="pre">class`</span> <span class="pre">類型的靜態或全局變數,</span> <span class="pre">可以考慮在</span> <span class="pre">``main()</span></tt> 函數或 <tt class="docutils literal"><span class="pre">pthread_once()</span></tt> 內初始化一個你永遠不會回收的指針.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>yospaly 譯註:</p>
<p class="last">上文提及的靜態變數泛指靜態生存周期的對象, 包括: 全局變數, 靜態變數, 靜態類成員變數, 以及函數靜態變數.</p>
</div>
</div>
<div class="section" id="yulefox">
<h2>譯者 (YuleFox) 筆記</h2>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">cc</span></tt> 中的匿名名字空間可避免命名衝突, 限定作用域, 避免直接使用 <tt class="docutils literal"><span class="pre">using</span></tt> 關鍵字污染命名空間;</li>
<li>嵌套類符合局部使用原則, 只是不能在其他標頭檔中前置聲明, 儘量不要 <tt class="docutils literal"><span class="pre">public</span></tt>;</li>
<li>儘量不用全局函數和全局變數, 考慮作用域和命名空間限制, 儘量單獨形成編譯單元;</li>
<li>多綫程中的全局變數 (含靜態成員變數) 不要使用 <tt class="docutils literal"><span class="pre">class</span></tt> 類型 (含 STL 容器), 避免不明確行為導致的 bug.</li>
<li>作用域的使用, 除了考慮名稱污染, 可讀性之外, 主要是為降低耦合, 提高編譯/執行效率.</li>
</ol>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="headers.html">1. 標頭檔</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../contents.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="classes.html">3. 類</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright .
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>