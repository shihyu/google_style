<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. 其他 C++ 特性 &mdash; Google C++ Style Guide</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.133',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Google C++ Style Guide" href="index.html" />
    <link rel="next" title="6. 命名約定" href="naming.html" />
    <link rel="prev" title="4. 來自 Google 的奇技" href="magic.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="naming.html" title="6. 命名約定"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="magic.html" title="4. 來自 Google 的奇技"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Google C++ Style Guide</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">5. 其他 C++ 特性</a><ul>
<li><a class="reference external" href="#id1">5.1. 引用參數</a></li>
<li><a class="reference external" href="#function-overloading">5.2. 函數重載</a></li>
<li><a class="reference external" href="#id5">5.3. 預設參數</a></li>
<li><a class="reference external" href="#alloca">5.4. 變長數組和 alloca()</a></li>
<li><a class="reference external" href="#id6">5.5. 友元</a></li>
<li><a class="reference external" href="#id7">5.6. 異常</a></li>
<li><a class="reference external" href="#id8">5.7. 運行時類型識別</a></li>
<li><a class="reference external" href="#id9">5.8. 類型轉換</a></li>
<li><a class="reference external" href="#id11">5.9. 流</a></li>
<li><a class="reference external" href="#id12">5.10. 前置自增和自減</a></li>
<li><a class="reference external" href="#const">5.11. <tt class="docutils literal"><span class="pre">const</span></tt> 的使用</a></li>
<li><a class="reference external" href="#id13">5.12. 整型</a></li>
<li><a class="reference external" href="#id14">5.13. 64 位下的可移植性</a></li>
<li><a class="reference external" href="#preprocessor-macros">5.14. 預處理宏</a></li>
<li><a class="reference external" href="#null">5.15. 0 和 NULL</a></li>
<li><a class="reference external" href="#sizeof">5.16. sizeof</a></li>
<li><a class="reference external" href="#boost">5.17. Boost 庫</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="magic.html"
                                  title="previous chapter">4. 來自 Google 的奇技</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="naming.html"
                                  title="next chapter">6. 命名約定</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/others.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="c">
<h1>5. 其他 C++ 特性<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>5.1. 引用參數<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所以按引用傳遞的參數必須加上 <tt class="docutils literal"><span class="pre">const</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>在 C 語言中, 如果函數需要修改變數的值, 參數必須為指針, 如 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">*pval)</span></tt>. 在 C++ 中, 函數還可以聲明引用參數: <tt class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">&amp;val)</span></tt>.</dd>
<dt>優點:</dt>
<dd>定義引用參數防止出現 <tt class="docutils literal"><span class="pre">(*pval)++</span></tt> 這樣醜陋的代碼. 像拷貝建構子這樣的應用也是必需的. 而且更明確, 不接受 <tt class="docutils literal"><span class="pre">NULL</span></tt> 指針.</dd>
<dt>缺點:</dt>
<dd>容易引起誤解, 因為引用在語法上是值變數卻擁有指針的語義.</dd>
<dt>結論:</dt>
<dd><dl class="first docutils">
<dt>函數參數列表中, 所有引用參數都必須是 <tt class="docutils literal"><span class="pre">const</span></tt>:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
</dd>
</dl>
<p>事實上這在 Google Code 是一個硬性約定: 輸入參數是值參或 <tt class="docutils literal"><span class="pre">const</span></tt> 引用, 輸出參數為指針. 輸入參數可以是 <tt class="docutils literal"><span class="pre">const</span></tt> 指針, 但決不能是 非 <tt class="docutils literal"><span class="pre">const</span></tt> 的引用參數.</p>
<p class="last">在以下情況你可以把輸入參數定義為 <tt class="docutils literal"><span class="pre">const</span></tt> 指針: 你想強調參數不是拷貝而來的, 在對象生存周期內必須一直存在; 最好同時在註釋中詳細說明一下. <tt class="docutils literal"><span class="pre">bind2nd</span></tt> 和 <tt class="docutils literal"><span class="pre">mem_fun</span></tt> 等 STL 適配器不接受引用參數, 這種情況下你也必須把函數參數聲明成指針類型.</p>
</dd>
</dl>
</div>
<div class="section" id="function-overloading">
<span id="id2"></span><h2>5.2. 函數重載<a class="headerlink" href="#function-overloading" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">僅在輸入參數類型不同, 功能相同時使用重載函數 (含建構子). 不要用函數重載模擬 <a class="reference external" href="http://code.google.com/p/google-gflags/">預設函數參數</a>.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd><dl class="first last docutils">
<dt>你可以編寫一個參數類型為 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">string&amp;</span></tt> 的函數, 然後用另一個參數類型為 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt> 的函數重載它:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">textlen</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt>優點:</dt>
<dd>通過重載參數不同的同名函數, 令代碼更加直觀. 模板化代碼需要重載, 同時為使用者帶來便利.</dd>
<dt>缺點:</dt>
<dd>限制使用重載的一個原因是在某個特定調用點很難確定到底調用的是哪個函數. 另一個原因是當派生類只重載了某個函數的部分變體, 會令很多人對繼承的語義產生困惑. 此外在閲讀庫的用戶代碼時, 可能會因反對使用 <a class="reference external" href="http://code.google.com/p/google-gflags/">預設函數參數</a> 造成不必要的費解.</dd>
<dt>結論:</dt>
<dd>如果你想重載一個函數, 考慮讓函數名包含參數信息, 例如, 使用 <tt class="docutils literal"><span class="pre">AppendString()</span></tt>, <tt class="docutils literal"><span class="pre">AppendInt()</span></tt> 而不是 <tt class="docutils literal"><span class="pre">Append()</span></tt>.</dd>
</dl>
</div>
<div class="section" id="id5">
<h2>5.3. 預設參數<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我們不允許使用預設函數參數.</p>
</div>
<dl class="docutils">
<dt>優點:</dt>
<dd>多數情況下, 你寫的函數可能會用到很多的預設值, 但偶爾你也會修改這些預設值. 無須為了這些偶爾情況定義很多的函數, 用預設參數就能很輕鬆的做到這點.</dd>
<dt>缺點:</dt>
<dd>大家通常都是通過查看別人的代碼來推斷如何使用 API. 用了預設參數的代碼更難維護, 從老代碼複製粘貼而來的新代碼可能只包含部分參數. 當預設參數不適用於新代碼時可能會導致重大問題.</dd>
<dt>結論:</dt>
<dd>我們規定所有參數必須明確指定, 迫使程序員理解 API 和各參數值的意義, 避免默默使用他們可能都還沒意識到的預設參數.</dd>
</dl>
</div>
<div class="section" id="alloca">
<h2>5.4. 變長數組和 alloca()<a class="headerlink" href="#alloca" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我們不允許使用變長數組和 <tt class="docutils literal"><span class="pre">alloca()</span></tt>.</p>
</div>
<dl class="docutils">
<dt>優點:</dt>
<dd>變長數組具有渾然天成的語法. 變長數組和 <tt class="docutils literal"><span class="pre">alloca()</span></tt> 也都很高效.</dd>
<dt>缺點:</dt>
<dd>變長數組和 <tt class="docutils literal"><span class="pre">alloca()</span></tt> 不是標準 C++ 的組成部分. 更重要的是, 它們根據數據大小動態分配堆棧內存, 會引起難以發現的內存越界 bugs: &#8220;在我的機器上運行的好好的, 發佈後卻莫名其妙的掛掉了&#8221;.</dd>
<dt>結論:</dt>
<dd>使用安全的內存分配器, 如 <tt class="docutils literal"><span class="pre">scoped_ptr</span></tt> / <tt class="docutils literal"><span class="pre">scoped_array</span></tt>.</dd>
</dl>
</div>
<div class="section" id="id6">
<h2>5.5. 友元<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我們允許合理的使用友元類及友元函數.</p>
</div>
<p>通常友元應該定義在同一檔案內, 避免代碼讀者跑到其它檔案查找使用該私有成員的類. 經常用到友元的一個地方是將 <tt class="docutils literal"><span class="pre">FooBuilder</span></tt> 聲明為 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的友元, 以便 <tt class="docutils literal"><span class="pre">FooBuilder</span></tt> 正確構造 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的內部狀態, 而無需將該狀態暴露出來. 某些情況下, 將一個單元測試類聲明成待測類的友元會很方便.</p>
<p>友元擴大了 (但沒有打破) 類的封裝邊界. 某些情況下, 相對於將類成員聲明為 <tt class="docutils literal"><span class="pre">public</span></tt>, 使用友元是更好的選擇, 尤其是如果你只允許另一個類訪問該類的私有成員時. 當然, 大多數類都只應該通過其提供的公有成員進行互操作.</p>
</div>
<div class="section" id="id7">
<h2>5.6. 異常<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我們不使用 C++ 異常.</p>
</div>
<dl class="docutils">
<dt>優點:</dt>
<dd><ul class="first last simple">
<li>異常允許上層應用決定如何處理在底層嵌套函數中 &#8220;不可能出現的&#8221; 失敗, 不像錯誤碼記錄那麼含糊又易出錯;</li>
<li>很多現代語言都使用異常. 引入異常使得 C++ 與 Python, Java 以及其它 C++ 相近的語言更加兼容.</li>
<li>許多第三方 C++ 庫使用異常, 禁用異常將導致很難整合這些庫.</li>
<li>異常是處理建構子失敗的唯一方法. 雖然可以通過工廠函數或 <tt class="docutils literal"><span class="pre">Init()</span></tt> 方法替代異常, 但他們分別需要堆分配或新的 &#8220;無效&#8221; 狀態；</li>
<li>在測試框架中使用異常確實很方便.</li>
</ul>
</dd>
<dt>缺點:</dt>
<dd><ul class="first last simple">
<li>在現有函數中添加 <tt class="docutils literal"><span class="pre">throw</span></tt> 語句時, 你必須檢查所有調用點. 所有調用點得至少有基本的異常安全保護, 否則永遠捕獲不到異常, 只好 &#8220;開心的&#8221; 接受程序終止的結果. 例如, 如果 <tt class="docutils literal"><span class="pre">f()</span></tt> 調用了 <tt class="docutils literal"><span class="pre">g()</span></tt>, <tt class="docutils literal"><span class="pre">g()</span></tt> 又調用了 <tt class="docutils literal"><span class="pre">h()</span></tt>, <tt class="docutils literal"><span class="pre">h</span></tt> 拋出的異常被 <tt class="docutils literal"><span class="pre">f</span></tt> 捕獲, <tt class="docutils literal"><span class="pre">g</span></tt> 要當心了, 很可能會因疏忽而未被妥善清理.</li>
<li>更普遍的情況是, 如果使用異常, 光憑查看代碼是很難評估程序的控制流: 函數返回點可能在你意料之外. 這回導致代碼管理和調試困難. 你可以通過規定何時何地如何使用異常來降低開銷, 但是讓開發人員必須掌握並理解這些規定帶來的代價更大.</li>
<li>異常安全要求同時採用 RAII 和不同編程實踐. 要想輕鬆編寫正確的異常安全代碼, 需要大量的支撐機制配合. 另外, 要避免代碼讀者去理解整個調用結構圖, 異常安全代碼必須把寫持久化狀態的邏輯部分隔離到 &#8220;提交&#8221; 階段. 它在帶來好處的同時, 還有成本 (也許你不得不為了隔離 &#8220;提交&#8221; 而整出令人費解的代碼). 允許使用異常會驅使我們不斷為此付出代價, 即使我們覺得這很不划算.</li>
<li>啟用異常使生成的二進制檔案體積變大, 延長了編譯時間 (或許影響不大), 還可能增加地址空間壓力;</li>
<li>異常的實用性可能會慫恿開發人員在不恰當的時候拋出異常, 或者在不安全的地方從異常中恢復. 例如, 處理非法用戶輸入時就不應該拋出異常. 如果我們要完全列出這些約束, 這份風格指南會長出很多!</li>
</ul>
</dd>
<dt>結論:</dt>
<dd><p class="first">從表面上看, 使用異常利大於弊, 尤其是在新項目中. 但是對於現有代碼, 引入異常會牽連到所有相關代碼. 如果新項目允許異常向外擴散, 在跟以前未使用異常的代碼整合時也將是個麻煩. 因為 Google 現有的大多數 C++ 代碼都沒有異常處理, 引入帶有異常處理的新代碼相當困難.</p>
<p>鑒於 Google 現有代碼不接受異常, 在現有代碼中使用異常比在新項目中使用的代價多少要大一些. 遷移過程比較慢, 也容易出錯. 我們不相信異常的使用有效替代方案, 如錯誤代碼, 斷言等會造成嚴重負擔.</p>
<p>我們並不是基于哲學或道德層面反對使用異常, 而是在實踐的基礎上. 我們希望在 Google 使用我們自己的開源項目, 但項目中使用異常會為此帶來不便, 因此我們也建議不要在 Google 的開源項目中使用異常. 如果我們需要把這些項目推倒重來顯然不太現實.</p>
<p class="last">對於 Windows 代碼來說, 有個 <a class="reference external" href="exceptions.html#windows-code"><em>特例</em></a>.</p>
</dd>
</dl>
<p>(YuleFox 註: 對於異常處理, 顯然不是短短幾句話能夠說清楚的, 以建構子為例, 很多 C++ 書籍上都提到當構造失敗時只有異常可以處理, Google 禁止使用異常這一點, 僅僅是為了自身的方便, 說大了, 無非是基于軟件管理成本上, 實際使用中還是自己決定)</p>
</div>
<div class="section" id="id8">
<h2>5.7. 運行時類型識別<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我們禁止使用 RTTI.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>RTTI 允許程序員在運行時識別 C++ 類對象的類型.</dd>
<dt>優點:</dt>
<dd><p class="first">RTTI 在某些單元測試中非常有用. 比如進行工廠類測試時, 用來驗證一個新建對象是否為期望的動態類型.</p>
<p class="last">除測試外, 極少用到.</p>
</dd>
<dt>缺點:</dt>
<dd>在運行時判斷類型通常意味着設計問題. 如果你需要在運行期間確定一個對象的類型, 這通常說明你需要考慮重新設計你的類.</dd>
<dt>結論:</dt>
<dd><p class="first">除單元測試外, 不要使用 RTTI. 如果你發現自己不得不寫一些行為邏輯取決於對象類型的代碼, 考慮換一種方式判斷對象類型.</p>
<p>如果要實現根據子類類型來確定執行不同邏輯代碼, 虛函數無疑更合適. 在對象內部就可以處理類型識別問題.</p>
<p>如果要在對象外部的代碼中判斷類型, 考慮使用雙重分派方案, 如訪問者模式. 可以方便的在對象本身之外確定類的類型.</p>
<p class="last">如果你認為上面的方法你真的掌握不了, 你可以使用 RTTI, 但務必請三思 :-) . 不要試圖手工實現一個貌似 RTTI 的替代方案, 我們反對使用 RTTI 的理由, 同樣適用於那些在類型繼承體繫上使用類型標籤的替代方案.</p>
</dd>
</dl>
</div>
<div class="section" id="id9">
<h2>5.8. 類型轉換<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 C++ 的類型轉換, 如 <tt class="docutils literal"><span class="pre">static_cast&lt;&gt;()</span></tt>. 不要使用 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(int)x</span></tt> 或 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">int(x)</span></tt> 等轉換方式;</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>C++ 採用了有別于 C 的類型轉換機制, 對轉換操作進行歸類.</dd>
<dt>優點:</dt>
<dd>C 語言的類型轉換問題在於模棱兩可的操作; 有時是在做強制轉換 (如 <tt class="docutils literal"><span class="pre">(int)3.5</span></tt>), 有時是在做類型轉換 (如 <tt class="docutils literal"><span class="pre">(int)&quot;hello&quot;</span></tt>). 另外, C++ 的類型轉換在查找時更醒目.</dd>
<dt>缺點:</dt>
<dd>噁心的語法.</dd>
<dt>結論:</dt>
<dd><p class="first">不要使用 C 風格類型轉換. 而應該使用 C++ 風格.</p>
<blockquote class="last">
<ul class="simple">
<li>用 <tt class="docutils literal"><span class="pre">static_cast</span></tt> 替代 C 風格的值轉換, 或某個類指針需要明確的向上轉換為父類指針時.</li>
<li>用 <tt class="docutils literal"><span class="pre">const_cast</span></tt> 去掉 <tt class="docutils literal"><span class="pre">const</span></tt> 限定符.</li>
<li>用 <tt class="docutils literal"><span class="pre">reinterpret_cast</span></tt> 指針類型和整型或其它指針之間進行不安全的相互轉換. 僅在你對所做一切瞭然於心時使用.</li>
<li><tt class="docutils literal"><span class="pre">dynamic_cast</span></tt> 測試代碼以外不要使用. 除非是單元測試, 如果你需要在運行時確定類型信息, 說明有 <a class="reference external" href="designflaw">設計缺陷</a>.</li>
</ul>
</blockquote>
</dd>
</dl>
</div>
<div class="section" id="id11">
<h2>5.9. 流<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只在記錄日誌時使用流.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>流用來替代 <tt class="docutils literal"><span class="pre">printf()</span></tt> 和 <tt class="docutils literal"><span class="pre">scanf()</span></tt>.</dd>
<dt>優點:</dt>
<dd>有了流, 在打印時不需要關心對象的類型. 不用擔心格式化字元串與參數列表不匹配 (雖然在 gcc 中使用 <tt class="docutils literal"><span class="pre">printf</span></tt> 也不存在這個問題). 流的構造和解構子會自動打開和關閉對應的檔案.</dd>
<dt>缺點:</dt>
<dd>流使得 <tt class="docutils literal"><span class="pre">pread()</span></tt> 等功能函數很難執行. 如果不使用 <tt class="docutils literal"><span class="pre">printf</span></tt> 風格的格式化字元串, 某些格式化操作 (尤其是常用的格式字元串 <tt class="docutils literal"><span class="pre">%.*s</span></tt>) 用流處理性能是很低的. 流不支持字元串操作符重新排序 (%1s), 而這一點對於軟件國際化很有用.</dd>
<dt>結論:</dt>
<dd><p class="first">不要使用流, 除非是日誌介面需要. 使用 <tt class="docutils literal"><span class="pre">printf</span></tt> 之類的代替.</p>
<p class="last">使用流還有很多利弊, 但代碼一致性勝過一切. 不要在代碼中使用流.</p>
</dd>
<dt>拓展討論:</dt>
<dd><p class="first">對這一條規則存在一些爭論, 這兒給出點深層次原因. 回想一下唯一性原則 (Only One Way): 我們希望在任何時候都只使用一種確定的 I/O 類型, 使代碼在所有 I/O 處都保持一致. 因此, 我們不希望用戶來決定是使用流還是 <tt class="docutils literal"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></tt>. 相反, 我們應該決定到底用哪一種方式. 把日誌作為特例是因為日誌是一個非常獨特的應用, 還有一些是歷史原因.</p>
<dl class="docutils">
<dt>流的支持者們主張流是不二之選, 但觀點並不是那麼清晰有力. 他們指出的流的每個優勢也都是其劣勢. 流最大的優勢是在輸出時不需要關心打印對象的類型. 這是一個亮點. 同時, 也是一個不足: 你很容易用錯類型, 而編譯器不會報警. 使用流時容易造成的這類錯誤:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="p">;</span>   <span class="c">// Prints the address</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c">// Prints the contents</span>
</pre></div>
</div>
</dd>
</dl>
<p>由於 <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> 被重載, 編譯器不會報錯. 就因為這一點我們反對使用操作符重載.</p>
<dl class="docutils">
<dt>有人說 <tt class="docutils literal"><span class="pre">printf</span></tt> 的格式化醜陋不堪, 易讀性差, 但流也好不到哪兒去. 看看下面兩段代碼吧, 實現相同的功能, 哪個更清晰?</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error connecting to &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error connecting to &#39;%s:%u: %s&quot;</span><span class="p">,</span>
        <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
        <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</pre></div>
</div>
</dd>
</dl>
<p>你可能會說, &#8220;把流封裝一下就會比較好了&#8221;, 這兒可以, 其他地方呢? 而且不要忘了, 我們的目標是使語言更緊湊, 而不是添加一些別人需要學習的新裝備.</p>
<p class="last">每一種方式都是各有利弊, &#8220;沒有最好, 只有更適合&#8221;. 簡單性原則告誡我們必須從中選擇其一, 最後大多數決定採用 <tt class="docutils literal"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></tt>.</p>
</dd>
</dl>
</div>
<div class="section" id="id12">
<h2>5.10. 前置自增和自減<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">對於迭代器和其他模板對象使用首碼形式 (<tt class="docutils literal"><span class="pre">++i</span></tt>) 的自增, 自減運算符.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>對於變數在自增 (<tt class="docutils literal"><span class="pre">++i</span></tt> 或 <tt class="docutils literal"><span class="pre">i++</span></tt>) 或自減 (<tt class="docutils literal"><span class="pre">--i</span></tt> 或 <tt class="docutils literal"><span class="pre">i--</span></tt>) 後表達式的值又沒有沒用到的情況下, 需要確定到底是使用前置還是後置的自增 (自減).</dd>
<dt>優點:</dt>
<dd>不考慮返回值的話, 前置自增 (<tt class="docutils literal"><span class="pre">++i</span></tt>) 通常要比後置自增 (<tt class="docutils literal"><span class="pre">i++</span></tt>) 效率更高. 因為後置自增 (或自減) 需要對錶達式的值 <tt class="docutils literal"><span class="pre">i</span></tt> 進行一次拷貝. 如果 <tt class="docutils literal"><span class="pre">i</span></tt> 是迭代器或其他非數值類型, 拷貝的代價是比較大的. 既然兩種自增方式實現的功能一樣, 為什麼不總是使用前置自增呢?</dd>
<dt>缺點:</dt>
<dd>在 C 開發中, 當表達式的值未被使用時, 傳統的做法是使用後置自增, 特別是在 <tt class="docutils literal"><span class="pre">for</span></tt> 循環中. 有些人覺得後置自增更加易懂, 因為這很像自然語言, 主語 (<tt class="docutils literal"><span class="pre">i</span></tt>) 在謂語動詞 (<tt class="docutils literal"><span class="pre">++</span></tt>) 前.</dd>
<dt>結論:</dt>
<dd>對簡單數值 (非對象), 兩種都無所謂. 對迭代器和模板類型, 使用前置自增 (自減).</dd>
</dl>
</div>
<div class="section" id="const">
<h2>5.11. <tt class="docutils literal"><span class="pre">const</span></tt> 的使用<a class="headerlink" href="#const" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我們強烈建議你在任何可能的情況下都要使用 <tt class="docutils literal"><span class="pre">const</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>在聲明的變數或參數前加上關鍵字 <tt class="docutils literal"><span class="pre">const</span></tt> 用於指明變數值不可被篡改 (如 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">foo</span></tt> ). 為類中的函數加上 <tt class="docutils literal"><span class="pre">const</span></tt> 限定符表明該函數不會修改類成員變數的狀態 (如 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">Bar(char</span> <span class="pre">c)</span> <span class="pre">const;</span> <span class="pre">};</span></tt>).</dd>
<dt>優點:</dt>
<dd>大家更容易理解如何使用變數. 編譯器可以更好地進行類型檢測, 相應地, 也能生成更好的代碼. 人們對編寫正確的代碼更加自信, 因為他們知道所調用的函數被限定了能或不能修改變數值. 即使是在無鎖的多綫程編程中, 人們也知道什麼樣的函數是安全的.</dd>
<dt>缺點:</dt>
<dd><tt class="docutils literal"><span class="pre">const</span></tt> 是入侵性的: 如果你向一個函數傳入 <tt class="docutils literal"><span class="pre">const</span></tt> 變數, 函數原型聲明中也必須對應 <tt class="docutils literal"><span class="pre">const</span></tt> 參數 (否則變數需要 <tt class="docutils literal"><span class="pre">const_cast</span></tt> 類型轉換), 在調用庫函數時顯得尤其麻煩.</dd>
<dt>結論:</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">const</span></tt> 變數, 數據成員, 函數和參數為編譯時類型檢測增加了一層保障; 便于儘早發現錯誤. 因此, 我們強烈建議在任何可能的情況下使用 <tt class="docutils literal"><span class="pre">const</span></tt>:</p>
<blockquote>
<ul class="simple">
<li>如果函數不會修改傳入的引用或指針類型參數, 該參數應聲明為 <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
<li>儘可能將函數聲明為 <tt class="docutils literal"><span class="pre">const</span></tt>. 訪問函數應該總是 <tt class="docutils literal"><span class="pre">const</span></tt>. 其他不會修改任何數據成員, 未調用非 <tt class="docutils literal"><span class="pre">const</span></tt> 函數, 不會返回數據成員非 <tt class="docutils literal"><span class="pre">const</span></tt> 指針或引用的函數也應該聲明成 <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
<li>如果數據成員在對象構造之後不再發生變化, 可將其定義為 <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
</ul>
</blockquote>
<p>然而, 也不要發了瘋似的使用 <tt class="docutils literal"><span class="pre">const</span></tt>. 像 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">x;</span></tt> 就有些過了, 雖然它非常精確的描述了常量 <tt class="docutils literal"><span class="pre">x</span></tt>. 關注真正有幫助意義的信息: 前面的例子寫成 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int**</span> <span class="pre">x</span></tt> 就夠了.</p>
<p class="last">關鍵字 <tt class="docutils literal"><span class="pre">mutable</span></tt> 可以使用, 但是在多綫程中是不安全的, 使用時首先要考慮綫程安全.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">const</span></tt> 的位置:</dt>
<dd><p class="first">有人喜歡 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">const</span> <span class="pre">*foo</span></tt> 形式, 不喜歡 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">foo</span></tt>, 他們認為前者更一致因此可讀性也更好: 遵循了 <tt class="docutils literal"><span class="pre">const</span></tt> 總位於其描述的對象之後的原則. 但是一致性原則不適用於此, &#8220;不要過度使用&#8221; 的聲明可以取消大部分你原本想保持的一致性. 將 <tt class="docutils literal"><span class="pre">const</span></tt> 放在前面才更易讀, 因為在自然語言中形容詞 (<tt class="docutils literal"><span class="pre">const</span></tt>) 是在名詞 (<tt class="docutils literal"><span class="pre">int</span></tt>) 之前.</p>
<p class="last">這是說, 我們提倡但不強制 <tt class="docutils literal"><span class="pre">const</span></tt> 在前. 但要保持代碼的一致性! (yospaly 註: 也就是不要在一些地方把 <tt class="docutils literal"><span class="pre">const</span></tt> 寫在類型前面, 在其他地方又寫在後面, 確定一種寫法, 然後保持一致.)</p>
</dd>
</dl>
</div>
<div class="section" id="id13">
<h2>5.12. 整型<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">C++ 內建整型中, 僅使用 <tt class="docutils literal"><span class="pre">int</span></tt>. 如果程序中需要不同大小的變數, 可以使用 <tt class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></tt> 中長度精確的整型, 如 <tt class="docutils literal"><span class="pre">int16_t</span></tt>.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd>C++ 沒有指定整型的大小. 通常人們假定 <tt class="docutils literal"><span class="pre">short</span></tt> 是 16 位, <tt class="docutils literal"><span class="pre">int``是</span> <span class="pre">32</span> <span class="pre">位,</span> <span class="pre">``long</span></tt> 是 32 位, <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> 是 64 位.</dd>
<dt>優點:</dt>
<dd>保持聲明統一.</dd>
<dt>缺點:</dt>
<dd>C++ 中整型大小因編譯器和體繫結構的不同而不同.</dd>
<dt>結論:</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></tt> 定義了 <tt class="docutils literal"><span class="pre">int16_t</span></tt>, <tt class="docutils literal"><span class="pre">uint32_t</span></tt>, <tt class="docutils literal"><span class="pre">int64_t</span></tt> 等整型, 在需要確保整型大小時可以使用它們代替 <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> 等. 在 C 整型中, 只使用 <tt class="docutils literal"><span class="pre">int</span></tt>. 在合適的情況下, 推薦使用標準類型如 <tt class="docutils literal"><span class="pre">size_t</span></tt> 和 <tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt>.</p>
<p>如果已知整數不會太大, 我們常常會使用 <tt class="docutils literal"><span class="pre">int</span></tt>, 如循環計數. 在類似的情況下使用原生類型 <tt class="docutils literal"><span class="pre">int</span></tt>. 你可以認為 <tt class="docutils literal"><span class="pre">int</span></tt> 至少為 32 位, 但不要認為它會多於 <tt class="docutils literal"><span class="pre">32</span></tt> 位. 如果需要 64 位整型, 用 <tt class="docutils literal"><span class="pre">int64_t</span></tt> 或 <tt class="docutils literal"><span class="pre">uint64_t</span></tt>.</p>
<p>對於大整數, 使用 <tt class="docutils literal"><span class="pre">int64_t</span></tt>.</p>
<p class="last">不要使用 <tt class="docutils literal"><span class="pre">uint32_t</span></tt> 等無符號整型, 除非你是在表示一個位組而不是一個數值, 或是你需要定義二進制補碼溢出. 尤其是不要為了指出數值永不會為負, 而使用無符號類型. 相反, 你應該使用斷言來保護數據.</p>
</dd>
<dt>關於無符號整數:</dt>
<dd><dl class="first docutils">
<dt>有些人, 包括一些教科書作者, 推薦使用無符號類型表示非負數. 這種做法試圖達到自我文檔化. 但是, 在 C 語言中, 這一優點被由其導致的 bug 所淹沒. 看看下面的例子:</dt>
<dd><div class="first last highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">Length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
</dd>
</dl>
<p>上述循環永遠不會退出! 有時 gcc 會發現該 bug 並報警, 但大部分情況下都不會. 類似的 bug 還會出現在比較有符合變數和無符號變數時. 主要是 C 的類型提升機制會致使無符號類型的行為出乎你的意料.</p>
<p class="last">因此, 使用斷言來指出變數為非負數, 而不是使用無符號型!</p>
</dd>
</dl>
</div>
<div class="section" id="id14">
<h2>5.13. 64 位下的可移植性<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">代碼應該對 64 位和 32 位系統友好. 處理打印, 比較, 結構體對齊時應切記:</p>
</div>
<ul>
<li><p class="first">對於某些類型, <tt class="docutils literal"><span class="pre">printf()</span></tt> 的指示符在 32 位和 64 位系統上可移植性不是很好. C99 標準定義了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 並非全部支持, 而且標準中也有所遺漏, 所以有時我們不得不自己定義一個醜陋的版本 (標頭檔 <tt class="docutils literal"><span class="pre">inttypes.h</span></tt> 仿標準風格):</p>
<blockquote>
<div class="highlight-c++"><div class="highlight"><pre><span class="c">// printf macros for size_t, in the style of inttypes.h</span>
<span class="cp">#ifdef _LP64</span>
<span class="cp">#define __PRIS_PREFIX &quot;z&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define __PRIS_PREFIX</span>
<span class="cp">#endif</span>

<span class="c">// Use these macros after a % in a printf format string</span>
<span class="c">// to get correct 32/64 bit behavior, like this:</span>
<span class="c">// size_t size = records.size();</span>
<span class="c">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span>
<span class="cp">#define PRIdS __PRIS_PREFIX &quot;d&quot;</span>
<span class="cp">#define PRIxS __PRIS_PREFIX &quot;x&quot;</span>
<span class="cp">#define PRIuS __PRIS_PREFIX &quot;u&quot;</span>
<span class="cp">#define PRIXS __PRIS_PREFIX &quot;X&quot;</span>
<span class="cp">#define PRIoS __PRIS_PREFIX &quot;o&quot;</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="25%" />
<col width="31%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p class="first last">類型</p>
</th>
<th class="head"><p class="first last">不要使用</p>
</th>
<th class="head"><p class="first last">使用</p>
</th>
<th class="head"><p class="first last">備註</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>
(或其他指針類型)</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%lx</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%p</span></tt></p>
</td>
<td>&nbsp;</td>
</tr>
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">int64_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%qd,</span> <span class="pre">%lld</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRId64&quot;</span></tt></p>
</td>
<td>&nbsp;</td>
</tr>
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">uint64_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%qu,</span> <span class="pre">%llu,</span> <span class="pre">%llx</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRIu64&quot;,</span> <span class="pre">%&quot;PRIx64&quot;</span></tt></p>
</td>
<td>&nbsp;</td>
</tr>
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">size_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%u</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRIuS&quot;,</span> <span class="pre">%&quot;PRIxS&quot;</span></tt></p>
</td>
<td><p class="first last">C99 規定 <tt class="docutils literal"><span class="pre">%zu</span></tt></p>
</td>
</tr>
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%d</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">%&quot;PRIdS&quot;</span></tt></p>
</td>
<td><p class="first last">C99 規定 <tt class="docutils literal"><span class="pre">%zd</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>注意 <tt class="docutils literal"><span class="pre">PRI*</span></tt> 宏會被編譯器擴展為獨立字元串. 因此如果使用非常量的格式化字元串, 需要將宏的值而不是宏名插入格式中. 使用 <tt class="docutils literal"><span class="pre">PRI*</span></tt> 宏同樣可以在 <tt class="docutils literal"><span class="pre">%</span></tt> 後包含長度指示符. 例如, <tt class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;PRIuS&quot;\n&quot;,</span> <span class="pre">x)</span></tt> 在 32 位 Linux 上將被展開為 <tt class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;</span> <span class="pre">&quot;u&quot;</span> <span class="pre">&quot;\n&quot;,</span> <span class="pre">x)</span></tt>, 編譯器當成 <tt class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30u\n&quot;,</span> <span class="pre">x)</span></tt> 處理 (yospaly 註: 這在 MSVC 6.0 上行不通, VC 6 編譯器不會自動把引號間隔的多個字元串連接一個長字元串).</p>
</blockquote>
</li>
<li><p class="first">記住 <tt class="docutils literal"><span class="pre">sizeof(void</span> <span class="pre">*)</span> <span class="pre">!=</span> <span class="pre">sizeof(int)</span></tt>. 如果需要一個指針大小的整數要用 <tt class="docutils literal"><span class="pre">intptr_t</span></tt>.</p>
</li>
<li><p class="first">你要非常小心的對待結構體對齊, 尤其是要持久化到磁碟上的結構體 (yospaly 註: 持久化 - 將數據按位元組流順序保存在磁碟檔案或資料庫中). 在 64 位系統中, 任何含有 <tt class="docutils literal"><span class="pre">int64_t</span></tt>/<tt class="docutils literal"><span class="pre">uint64_t</span></tt> 成員的類/結構體, 預設都以 8 位元組在結尾對齊. 如果 32 位和 64 位代碼要共用持久化的結構體, 需要確保兩種體繫結構下的結構體對齊一致. 大多數編譯器都允許調整結構體對齊. gcc 中可使用 <tt class="docutils literal"><span class="pre">__attribute__((packed))</span></tt>. MSVC 則提供了 <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack()</span></tt> 和 <tt class="docutils literal"><span class="pre">__declspec(align())</span></tt> (YuleFox 注, 解決方案的項目屬性裡也可以直接設置).</p>
</li>
<li><dl class="first docutils">
<dt>創建 64 位常量時使用 LL 或 ULL 作為尾碼, 如:</dt>
<dd><div class="first last highlight-c++"><pre>int64_t my_value = 0×123456789LL;
uint64_t my_mask = 3ULL &lt;&lt; 48;</pre>
</div>
</dd>
</dl>
</li>
<li><p class="first">如果你確實需要 32 位和 64 位系統具有不同代碼, 可以使用 <tt class="docutils literal"><span class="pre">#ifdef</span> <span class="pre">_LP64</span></tt> 指令來切分 32/64 位代碼. (儘量不要這麼做, 如果非用不可, 儘量使修改局部化)</p>
</li>
</ul>
</div>
<div class="section" id="preprocessor-macros">
<span id="id15"></span><h2>5.14. 預處理宏<a class="headerlink" href="#preprocessor-macros" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用宏時要非常謹慎, 儘量以內聯函數, 枚舉和常量代替之.</p>
</div>
<p>宏意味着你和編譯器看到的代碼是不同的. 這可能會導致異常行為, 尤其因為宏具有全局作用域.</p>
<p>值得慶幸的是, C++ 中, 宏不像在 C 中那麼必不可少. 以往用宏展開性能關鍵的代碼, 現在可以用內聯函數替代. 用宏表示常量可被 <tt class="docutils literal"><span class="pre">const</span></tt> 變數代替. 用宏 &#8220;縮寫&#8221; 長變數名可被引用代替. 用宏進行條件編譯... 這個, 千萬別這麼做, 會令測試更加痛苦 (<tt class="docutils literal"><span class="pre">#define</span></tt> 防止標頭檔重包含當然是個特例).</p>
<p>宏可以做一些其他技術無法實現的事情, 在一些代碼庫 (尤其是底層庫中) 可以看到宏的某些特性 (如用 <tt class="docutils literal"><span class="pre">#</span></tt> 字元串化, 用 <tt class="docutils literal"><span class="pre">##</span></tt> 連接等等). 但在使用前, 仔細考慮一下能不能不使用宏達到同樣的目的.</p>
<p>下面給出的用法模式可以避免使用宏帶來的問題; 如果你要宏, 儘可能遵守:</p>
<blockquote>
<ul class="simple">
<li>不要在 <tt class="docutils literal"><span class="pre">.h</span></tt> 檔案中定義宏.</li>
<li>在馬上要使用時才進行 <tt class="docutils literal"><span class="pre">#define</span></tt>, 使用後要立即 <tt class="docutils literal"><span class="pre">#undef</span></tt>.</li>
<li>不要只是對已經存在的宏使用#undef，選擇一個不會衝突的名稱；</li>
<li>不要試圖使用展開後會導致 C++ 構造不穩定的宏, 不然也至少要附上文檔說明其行為.</li>
</ul>
</blockquote>
</div>
<div class="section" id="null">
<h2>5.15. 0 和 NULL<a class="headerlink" href="#null" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">整數用 <tt class="docutils literal"><span class="pre">0</span></tt>, 實數用 <tt class="docutils literal"><span class="pre">0.0</span></tt>, 指針用 <tt class="docutils literal"><span class="pre">NULL</span></tt>, 字元 (串) 用 <tt class="docutils literal"><span class="pre">'\0'</span></tt>.</p>
</div>
<p>整數用 <tt class="docutils literal"><span class="pre">0</span></tt>, 實數用 <tt class="docutils literal"><span class="pre">0.0</span></tt>, 這一點是毫無爭議的.</p>
<p>對於指針 (地址值), 到底是用 <tt class="docutils literal"><span class="pre">0</span></tt> 還是 <tt class="docutils literal"><span class="pre">NULL</span></tt>, Bjarne Stroustrup 建議使用最原始的 <tt class="docutils literal"><span class="pre">0</span></tt>. 我們建議使用看上去像是指針的 <tt class="docutils literal"><span class="pre">NULL</span></tt>, 事實上一些 C++ 編譯器 (如 gcc 4.1.0) 對 <tt class="docutils literal"><span class="pre">NULL</span></tt> 進行了特殊的定義, 可以給出有用的警告信息, 尤其是 <tt class="docutils literal"><span class="pre">sizeof(NULL)</span></tt> 和 <tt class="docutils literal"><span class="pre">sizeof(0)</span></tt> 不相等的情況.</p>
<p>字元 (串) 用 <tt class="docutils literal"><span class="pre">'\0'</span></tt>, 不僅類型正確而且可讀性好.</p>
</div>
<div class="section" id="sizeof">
<h2>5.16. sizeof<a class="headerlink" href="#sizeof" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">儘可能用 <tt class="docutils literal"><span class="pre">sizeof(varname)</span></tt> 代替 <tt class="docutils literal"><span class="pre">sizeof(type)</span></tt>.</p>
</div>
<dl class="docutils">
<dt>使用 <tt class="docutils literal"><span class="pre">sizeof(varname)</span></tt> 是因為當代碼中變數類型改變時會自動更新. 某些情況下 <tt class="docutils literal"><span class="pre">sizeof(type)</span></tt> 或許有意義, 但還是要儘量避免, 因為它會導致變數類型改變後不能同步.</dt>
<dd><div class="first highlight-c++"><div class="highlight"><pre><span class="n">Struct</span> <span class="n">data</span><span class="p">;</span>
<span class="n">Struct</span> <span class="n">data</span><span class="p">;</span> <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Struct</span><span class="p">));</span>
</pre></div>
</div>
</div>
</dd>
</dl>
</div>
<div class="section" id="boost">
<h2>5.17. Boost 庫<a class="headerlink" href="#boost" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用 Boost 中被認可的庫.</p>
</div>
<dl class="docutils">
<dt>定義:</dt>
<dd><a class="reference external" href="http://www.boost.org/">Boost 庫集</a> 是一個廣受歡迎, 經過同行鑒定, 免費開源的 C++ 庫集.</dd>
<dt>優點:</dt>
<dd>Boost代碼質量普遍較高, 可移植性好, 填補了 C++ 標準庫很多空白, 如型別的特性, 更完善的綁定器, 更好的智能指針, 同時還提供了 <tt class="docutils literal"><span class="pre">TR1</span></tt> (標準庫擴展) 的實現.</dd>
<dt>缺點:</dt>
<dd>某些 Boost 庫提倡的編程實踐可讀性差, 比如元編程和其他高級模板技術, 以及過度 &#8220;函數化&#8221; 的編程風格.</dd>
<dt>結論:</dt>
<dd><p class="first">為了向閲讀和維護代碼的人員提供更好的可讀性, 我們只允許使用 Boost 一部分經認可的特性子集. 目前允許使用以下庫:</p>
<blockquote class="last">
<ul class="simple">
<li><a class="reference external" href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a> : <tt class="docutils literal"><span class="pre">boost/compressed_pair.hpp</span></tt></li>
<li><a class="reference external" href="http://www.boost.org/libs/ptr_container/">Pointer Container</a> : <tt class="docutils literal"><span class="pre">boost/ptr_container</span></tt> (序列化除外)</li>
<li><a class="reference external" href="http://www.boost.org/libs/array/">Array</a> : <tt class="docutils literal"><span class="pre">boost/array.hpp</span></tt></li>
<li><a class="reference external" href="http://www.boost.org/libs/graph/">The Boost Graph Library (BGL)</a> : <tt class="docutils literal"><span class="pre">boost/graph</span></tt> (序列化除外)</li>
<li><a class="reference external" href="http://www.boost.org/libs/property_map/">Property Map</a> : <tt class="docutils literal"><span class="pre">boost/property_map.hpp</span></tt></li>
<li><a class="reference external" href="http://www.boost.org/libs/iterator/">Iterator</a> 中處理迭代器定義的部分 : <tt class="docutils literal"><span class="pre">boost/iterator/iterator_adaptor.hpp</span></tt>, <tt class="docutils literal"><span class="pre">boost/iterator/iterator_facade.hpp</span></tt>, 以及 <tt class="docutils literal"><span class="pre">boost/function_output_iterator.hpp</span></tt></li>
</ul>
</blockquote>
</dd>
</dl>
<p>我們正在積極考慮增加其它 Boost 特性, 所以列表中的規則將不斷變化.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="naming.html" title="6. 命名約定"
             >next</a> |</li>
        <li class="right" >
          <a href="magic.html" title="4. 來自 Google 的奇技"
             >previous</a> |</li>
        <li><a href="index.html">Google C++ Style Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, Google Inc..
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.2.
    </div>
  </body>
</html>